<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Book Viewer (Rotate Only)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: transparent;
      font-family: 'Montserrat', sans-serif;
      touch-action: none; /* important: blocks pinch-zoom gestures */
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: relative;
      background: transparent;
    }

    canvas {
      display: block;
      cursor: grab;
      background: transparent;
      touch-action: none; /* important */
    }

    canvas:active { cursor: grabbing; }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // =========================
    // YOUR WIXSTATIC IMAGE URLS
    // =========================
    const FRONT_URL = "https://static.wixstatic.com/media/013f79_4778a342d3a04563bfae1cb95d962f83~mv2.png?v=5";
    const SPINE_URL = "https://static.wixstatic.com/media/013f79_8c03f9c79a534927b9e9e7f6005b78c3~mv2.png?v=5";
    const BACK_URL  = "https://static.wixstatic.com/media/013f79_115d84eed47d46e48c068319883fb662~mv2.png?v=5";

    let scene, camera, renderer, bookGroup;
    let isDragging = false;

    // Locked camera distance (keeps size stable)
    const LOCKED_CAMERA_Z = 8;

    init();

    function init() {
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, LOCKED_CAMERA_Z);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setClearColor(0x000000, 0);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      const container = document.getElementById("canvas-container");
      container.appendChild(renderer.domElement);

      // HARD BLOCK: wheel zoom + page scroll inside embed
      renderer.domElement.addEventListener("wheel", (e) => e.preventDefault(), { passive: false });

      // HARD BLOCK: iOS gesture zoom (older Safari)
      document.addEventListener("gesturestart", (e) => e.preventDefault());
      document.addEventListener("gesturechange", (e) => e.preventDefault());
      document.addEventListener("gestureend", (e) => e.preventDefault());

      // Lighting
      scene.add(new THREE.AmbientLight(0xffffff, 0.75));

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.85);
      directionalLight.position.set(5, 10, 7);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      const rimLight = new THREE.DirectionalLight(0xd4af37, 0.35);
      rimLight.position.set(-5, 5, -5);
      scene.add(rimLight);

      loadTextures(FRONT_URL, SPINE_URL, BACK_URL);
      window.addEventListener("resize", onResize);
    }

    function loadTextures(frontImage, spineImage, backImage) {
      const loader = new THREE.TextureLoader();
      loader.setCrossOrigin("anonymous");

      const textures = { front: null, spine: null, back: null };
      let loaded = 0;

      function done() {
        loaded++;
        if (loaded !== 3) return;

        const maxAniso = renderer.capabilities.getMaxAnisotropy();
        textures.front.anisotropy = maxAniso;
        textures.spine.anisotropy = maxAniso;
        textures.back.anisotropy  = maxAniso;

        textures.front.colorSpace = THREE.SRGBColorSpace;
        textures.spine.colorSpace = THREE.SRGBColorSpace;
        textures.back.colorSpace  = THREE.SRGBColorSpace;

        buildBook(textures.front, textures.spine, textures.back);
        setupRotationControls();
        fitBookToViewport(); // ensures consistent “hero size”
        animate();
      }

      function fail(which, url) {
        console.error(`Failed to load ${which}:`, url);
        alert(`Could not load ${which} image:\n${url}`);
      }

      textures.front = loader.load(frontImage, done, undefined, () => fail("front", frontImage));
      textures.spine = loader.load(spineImage, done, undefined, () => fail("spine", spineImage));
      textures.back  = loader.load(backImage,  done, undefined, () => fail("back", backImage));
    }

    function buildBook(frontTexture, spineTexture, backTexture) {
      bookGroup = new THREE.Group();

      // Base dimensions (matches your current look)
      const bookWidth = 2.5;
      const bookHeight = 3.5;
      const bookDepth = 0.5;

      const frontMat = new THREE.MeshStandardMaterial({ map: frontTexture, roughness: 0.4, metalness: 0.1 });
      const spineMat = new THREE.MeshStandardMaterial({ map: spineTexture, roughness: 0.5, metalness: 0.1 });
      const backMat  = new THREE.MeshStandardMaterial({ map: backTexture,  roughness: 0.4, metalness: 0.1 });
      const pagesMat = new THREE.MeshStandardMaterial({ color: 0xfff8e7, roughness: 0.9, metalness: 0.0 });

      const front = new THREE.Mesh(new THREE.BoxGeometry(bookWidth, bookHeight, 0.05), frontMat);
      front.position.z = bookDepth / 2;
      front.castShadow = true;
      bookGroup.add(front);

      const spine = new THREE.Mesh(new THREE.BoxGeometry(0.05, bookHeight, bookDepth), spineMat);
      spine.position.x = -bookWidth / 2;
      spine.castShadow = true;
      bookGroup.add(spine);

      const back = new THREE.Mesh(new THREE.BoxGeometry(bookWidth, bookHeight, 0.05), backMat);
      back.position.z = -bookDepth / 2;
      back.castShadow = true;
      bookGroup.add(back);

      const pages = new THREE.Mesh(
        new THREE.BoxGeometry(bookWidth - 0.05, bookHeight - 0.05, bookDepth - 0.1),
        pagesMat
      );
      pages.castShadow = true;
      bookGroup.add(pages);

      // Page lines
      const lineMat = new THREE.LineBasicMaterial({ color: 0xe8dcc0, transparent: true, opacity: 0.6 });
      const numPages = 25;
      for (let i = 0; i < numPages; i++) {
        const y = (i / numPages) * (bookHeight - 0.1) - (bookHeight - 0.1) / 2;
        const geo = new THREE.BufferGeometry();
        geo.setAttribute("position", new THREE.BufferAttribute(new Float32Array([
          bookWidth / 2 - 0.025, y, -bookDepth / 2 + 0.05,
          bookWidth / 2 - 0.025, y,  bookDepth / 2 - 0.05
        ]), 3));
        bookGroup.add(new THREE.Line(geo, lineMat));
      }

      // Page edges
      const edgeMat = new THREE.MeshStandardMaterial({ color: 0xf5e6d3, roughness: 0.95, metalness: 0.0 });
      const topEdge = new THREE.Mesh(new THREE.BoxGeometry(bookWidth - 0.05, 0.02, bookDepth - 0.1), edgeMat);
      topEdge.position.y = (bookHeight - 0.05) / 2;
      bookGroup.add(topEdge);

      const bottomEdge = topEdge.clone();
      bottomEdge.position.y = -(bookHeight - 0.05) / 2;
      bookGroup.add(bottomEdge);

      const rightEdge = new THREE.Mesh(new THREE.BoxGeometry(0.02, bookHeight - 0.05, bookDepth - 0.1), edgeMat);
      rightEdge.position.x = (bookWidth - 0.05) / 2;
      bookGroup.add(rightEdge);

      // Initial angle
      bookGroup.rotation.y = 0.3;
      bookGroup.rotation.x = 0.1;

      scene.add(bookGroup);
    }

    function setupRotationControls() {
      const el = renderer.domElement;
      let prev = { x: 0, y: 0 };

      el.addEventListener("mousedown", (e) => {
        isDragging = true;
        prev = { x: e.clientX, y: e.clientY };
      });

      el.addEventListener("mousemove", (e) => {
        if (!isDragging) return;
        const dx = e.clientX - prev.x;
        const dy = e.clientY - prev.y;

        bookGroup.rotation.y += dx * 0.01;
        bookGroup.rotation.x += dy * 0.01;

        // Keep it clean (no flipping)
        bookGroup.rotation.x = Math.max(-0.6, Math.min(0.6, bookGroup.rotation.x));

        prev = { x: e.clientX, y: e.clientY };
      });

      el.addEventListener("mouseup", () => { isDragging = false; });
      el.addEventListener("mouseleave", () => { isDragging = false; });

      // Touch rotate (single finger). Pinch is blocked by touch-action: none + wheel prevention.
      el.addEventListener("touchstart", (e) => {
        if (e.touches.length !== 1) return;
        isDragging = true;
        prev = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }, { passive: true });

      el.addEventListener("touchmove", (e) => {
        if (!isDragging || e.touches.length !== 1) return;

        const dx = e.touches[0].clientX - prev.x;
        const dy = e.touches[0].clientY - prev.y;

        bookGroup.rotation.y += dx * 0.01;
        bookGroup.rotation.x += dy * 0.01;

        bookGroup.rotation.x = Math.max(-0.6, Math.min(0.6, bookGroup.rotation.x));

        prev = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }, { passive: true });

      el.addEventListener("touchend", () => { isDragging = false; }, { passive: true });
    }

    // Keeps the book “hero-sized” consistently within the iframe
    function fitBookToViewport() {
      if (!bookGroup) return;

      // Center it nicely
      bookGroup.position.set(0, 0, 0);

      // Compute bounds
      const box = new THREE.Box3().setFromObject(bookGroup);
      const size = new THREE.Vector3();
      box.getSize(size);

      // Fill % of viewport height (tune this to match your screenshot)
      const targetFill = 0.78; // 78% of iframe height
      const vFov = THREE.MathUtils.degToRad(camera.fov);
      const visibleHeight = 2 * Math.tan(vFov / 2) * LOCKED_CAMERA_Z;

      const desiredBookHeight = visibleHeight * targetFill;
      const scale = desiredBookHeight / size.y;

      bookGroup.scale.setScalar(scale);
      camera.position.z = LOCKED_CAMERA_Z;
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);

      // keep size stable after resize
      fitBookToViewport();
    }

    function animate() {
      requestAnimationFrame(animate);

      // Lock camera distance (no zoom ever)
      if (camera.position.z !== LOCKED_CAMERA_Z) camera.position.z = LOCKED_CAMERA_Z;

      // optional slow idle spin
      if (!isDragging && bookGroup) bookGroup.rotation.y += 0.002;

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
