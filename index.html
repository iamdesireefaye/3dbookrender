<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Book Viewer (Auto-Load)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: transparent;
      font-family: 'Montserrat', sans-serif;
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: relative;
      background: transparent;
    }

    canvas {
      display: block;
      cursor: grab;
      background: transparent;
    }

    canvas:active { cursor: grabbing; }

    .instructions {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(26, 77, 46, 0.85);
      color: #d4af37;
      padding: 12px 22px;
      border-radius: 999px;
      font-size: 13px;
      font-weight: 600;
      text-align: center;
      pointer-events: none;
      z-index: 10;
      white-space: nowrap;
    }

    .badge {
      position: absolute;
      top: 18px;
      left: 50%;
      transform: translateX(-50%);
      background: #d4af37;
      color: #1a4d2e;
      padding: 8px 18px;
      border-radius: 999px;
      font-size: 11px;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      box-shadow: 0 6px 20px rgba(212, 175, 55, 0.35);
      z-index: 10;
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div class="badge">AMAZON #1 NEW RELEASE</div>
  <div class="instructions">Drag to rotate â€¢ Scroll to zoom</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // =========================
    // YOUR WIXSTATIC IMAGE URLS (unique)
    // =========================
    const DEFAULT_FRONT_URL = "https://static.wixstatic.com/media/013f79_4778a342d3a04563bfae1cb95d962f83~mv2.png?v=2";
    const DEFAULT_SPINE_URL = "https://static.wixstatic.com/media/013f79_8c03f9c79a534927b9e9e7f6005b78c3~mv2.png?v=2";
    const DEFAULT_BACK_URL  = "https://static.wixstatic.com/media/013f79_115d84eed47d46e48c068319883fb662~mv2.png?v=2";

    let scene, camera, renderer, bookGroup;

    // Auto-init on load (no upload UI)
    initScene(DEFAULT_FRONT_URL, DEFAULT_SPINE_URL, DEFAULT_BACK_URL);

    function initScene(frontImage, spineImage, backImage) {
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 8);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setClearColor(0x000000, 0); // transparent
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      document.getElementById('canvas-container').appendChild(renderer.domElement);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.75);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.85);
      directionalLight.position.set(5, 10, 7);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      const rimLight = new THREE.DirectionalLight(0xd4af37, 0.35);
      rimLight.position.set(-5, 5, -5);
      scene.add(rimLight);

      // Textures
      const textureLoader = new THREE.TextureLoader();
      textureLoader.setCrossOrigin('anonymous');

      const textures = { front: null, spine: null, back: null };
      let loadedCount = 0;

      function onLoaded() {
        loadedCount++;
        if (loadedCount === 3) {
          const maxAniso = renderer.capabilities.getMaxAnisotropy();
          textures.front.anisotropy = maxAniso;
          textures.spine.anisotropy = maxAniso;
          textures.back.anisotropy  = maxAniso;

          // Make colors correct
          textures.front.colorSpace = THREE.SRGBColorSpace;
          textures.spine.colorSpace = THREE.SRGBColorSpace;
          textures.back.colorSpace  = THREE.SRGBColorSpace;

          buildBook(textures.front, textures.spine, textures.back);
        }
      }

      function onError(which, url) {
        console.error(`Failed to load ${which} texture:`, url);
        alert(`Could not load ${which} image.\n\nCheck that the URL opens directly as an image:\n${url}`);
      }

      textures.front = textureLoader.load(frontImage, onLoaded, undefined, () => onError('front', frontImage));
      textures.spine = textureLoader.load(spineImage, onLoaded, undefined, () => onError('spine', spineImage));
      textures.back  = textureLoader.load(backImage,  onLoaded, undefined, () => onError('back', backImage));
    }

    function buildBook(frontTexture, spineTexture, backTexture) {
      bookGroup = new THREE.Group();

      // Book dimensions
      const bookWidth = 2.5;
      const bookHeight = 3.5;
      const bookDepth = 0.5;

      // Materials
      const frontMaterial = new THREE.MeshStandardMaterial({
        map: frontTexture,
        roughness: 0.4,
        metalness: 0.1
      });

      const spineMaterial = new THREE.MeshStandardMaterial({
        map: spineTexture,
        roughness: 0.5,
        metalness: 0.1
      });

      const backMaterial = new THREE.MeshStandardMaterial({
        map: backTexture,
        roughness: 0.4,
        metalness: 0.1
      });

      const pagesMaterial = new THREE.MeshStandardMaterial({
        color: 0xfff8e7,
        roughness: 0.9,
        metalness: 0.0
      });

      // Front cover
      const frontGeometry = new THREE.BoxGeometry(bookWidth, bookHeight, 0.05);
      const front = new THREE.Mesh(frontGeometry, frontMaterial);
      front.position.z = bookDepth / 2;
      front.castShadow = true;
      bookGroup.add(front);

      // Spine
      const spineGeometry = new THREE.BoxGeometry(0.05, bookHeight, bookDepth);
      const spine = new THREE.Mesh(spineGeometry, spineMaterial);
      spine.position.x = -bookWidth / 2;
      spine.castShadow = true;
      bookGroup.add(spine);

      // Back cover
      const backGeometry = new THREE.BoxGeometry(bookWidth, bookHeight, 0.05);
      const back = new THREE.Mesh(backGeometry, backMaterial);
      back.position.z = -bookDepth / 2;
      back.castShadow = true;
      bookGroup.add(back);

      // Pages block
      const pagesGeometry = new THREE.BoxGeometry(bookWidth - 0.05, bookHeight - 0.05, bookDepth - 0.1);
      const pages = new THREE.Mesh(pagesGeometry, pagesMaterial);
      pages.castShadow = true;
      bookGroup.add(pages);

      // Page lines
      const pageLinesMaterial = new THREE.LineBasicMaterial({
        color: 0xe8dcc0,
        transparent: true,
        opacity: 0.6
      });

      const numPages = 25;
      for (let i = 0; i < numPages; i++) {
        const y = (i / numPages) * (bookHeight - 0.1) - (bookHeight - 0.1) / 2;

        const lineGeometry = new THREE.BufferGeometry();
        const linePositions = new Float32Array([
          bookWidth / 2 - 0.025, y, -bookDepth / 2 + 0.05,
          bookWidth / 2 - 0.025, y,  bookDepth / 2 - 0.05
        ]);
        lineGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));

        const line = new THREE.Line(lineGeometry, pageLinesMaterial);
        bookGroup.add(line);
      }

      // Page edges
      const edgeMaterial = new THREE.MeshStandardMaterial({
        color: 0xf5e6d3,
        roughness: 0.95,
        metalness: 0.0
      });

      const topEdgeGeometry = new THREE.BoxGeometry(bookWidth - 0.05, 0.02, bookDepth - 0.1);
      const topEdge = new THREE.Mesh(topEdgeGeometry, edgeMaterial);
      topEdge.position.y = (bookHeight - 0.05) / 2;
      bookGroup.add(topEdge);

      const bottomEdge = new THREE.Mesh(topEdgeGeometry, edgeMaterial);
      bottomEdge.position.y = -(bookHeight - 0.05) / 2;
      bookGroup.add(bottomEdge);

      const rightEdgeGeometry = new THREE.BoxGeometry(0.02, bookHeight - 0.05, bookDepth - 0.1);
      const rightEdge = new THREE.Mesh(rightEdgeGeometry, edgeMaterial);
      rightEdge.position.x = (bookWidth - 0.05) / 2;
      bookGroup.add(rightEdge);

      // Initial angle
      bookGroup.rotation.y = 0.3;
      bookGroup.rotation.x = 0.1;
      scene.add(bookGroup);

      // Interaction
      let isDragging = false;
      let previousMousePosition = { x: 0, y: 0 };

      renderer.domElement.addEventListener('mousedown', (e) => {
        isDragging = true;
        previousMousePosition = { x: e.clientX, y: e.clientY };
      });

      renderer.domElement.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const deltaX = e.clientX - previousMousePosition.x;
        const deltaY = e.clientY - previousMousePosition.y;

        bookGroup.rotation.y += deltaX * 0.01;
        bookGroup.rotation.x += deltaY * 0.01;

        previousMousePosition = { x: e.clientX, y: e.clientY };
      });

      renderer.domElement.addEventListener('mouseup', () => { isDragging = false; });
      renderer.domElement.addEventListener('mouseleave', () => { isDragging = false; });

      // Touch
      renderer.domElement.addEventListener('touchstart', (e) => {
        isDragging = true;
        previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }, { passive: true });

      renderer.domElement.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        const deltaX = e.touches[0].clientX - previousMousePosition.x;
        const deltaY = e.touches[0].clientY - previousMousePosition.y;

        bookGroup.rotation.y += deltaX * 0.01;
        bookGroup.rotation.x += deltaY * 0.01;

        previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }, { passive: true });

      renderer.domElement.addEventListener('touchend', () => { isDragging = false; });

      // Zoom
      renderer.domElement.addEventListener('wheel', (e) => {
        e.preventDefault();
        camera.position.z += e.deltaY * 0.01;
        camera.position.z = Math.max(4, Math.min(12, camera.position.z));
      }, { passive: false });

      // Resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Animate
      function animate() {
        requestAnimationFrame(animate);
        if (!isDragging) bookGroup.rotation.y += 0.002;
        renderer.render(scene, camera);
      }
      animate();
    }
  </script>
</body>
</html>
